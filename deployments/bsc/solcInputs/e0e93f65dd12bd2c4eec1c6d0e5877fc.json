{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/abstract/dex/BaseUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IUniswapV2Factory} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport {IUniswapV2Pair} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Distributor {\n    constructor(address _USDT) {\n        IERC20(_USDT).approve(msg.sender, type(uint256).max);\n    }\n}\n\nabstract contract BaseUSDT {\n    bool public inSwapAndLiquify;\n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    Distributor public immutable distributor;\n    address public immutable USDT;\n    bool public immutable isFirstReserveU;\n\n    modifier lockTheSwap() {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n\n    constructor(address _USDT, address _ROUTER) {\n        USDT = _USDT;\n        uniswapV2Router = IUniswapV2Router02(_ROUTER);\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), _USDT);\n        distributor = new Distributor(_USDT);\n\n        isFirstReserveU = IUniswapV2Pair(uniswapV2Pair).token0() == _USDT;\n    }\n\n    function getReserves() public view returns (uint112, uint112) {\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(uniswapV2Pair).getReserves();\n        if (isFirstReserveU) {\n            return (reserve0, reserve1);\n        } else {\n            return (reserve1, reserve0);\n        }\n    }\n}\n"
    },
    "contracts/abstract/ExcludedFromFeeList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport {Owned} from \"./Owned.sol\";\n\nabstract contract ExcludedFromFeeList is Owned {\n    mapping(address => bool) internal _isExcludedFromFee;\n\n    event ExcludedFromFee(address account);\n    event IncludedToFee(address account);\n\n    function isExcludedFromFee(address account) public view returns (bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n        emit ExcludedFromFee(account);\n    }\n\n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n        emit IncludedToFee(account);\n    }\n\n    function excludeMultipleAccountsFromFee(address[] calldata accounts) public onlyOwner {\n        uint256 len = uint256(accounts.length);\n        for (uint256 i = 0; i < len;) {\n            _isExcludedFromFee[accounts[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/abstract/FirstLaunch.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nabstract contract FirstLaunch {\n    uint40 public launchedAtTimestamp;\n\n    function launch() internal {\n        require(launchedAtTimestamp == 0, \"Already launched\");\n        launchedAtTimestamp = uint40(block.timestamp);\n    }\n}"
    },
    "contracts/abstract/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n    // If a user mistakenly transfers tokens to this contract, this account can withdraw them.\n    address public abandonedBalanceOwner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n        abandonedBalanceOwner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "contracts/abstract/token/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public immutable totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply;\n        unchecked {\n            balanceOf[msg.sender] += _totalSupply;\n        }\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n        }\n\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n}"
    },
    "contracts/Ava.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IUniswapV2Pair} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport {FirstLaunch} from \"./abstract/FirstLaunch.sol\";\nimport {Owned} from \"./abstract/Owned.sol\";\nimport {ERC20} from \"./abstract/token/ERC20.sol\";\nimport {ExcludedFromFeeList} from \"./abstract/ExcludedFromFeeList.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Helper} from \"./lib/Helper.sol\";\nimport {BaseUSDT} from \"./abstract/dex/BaseUSDT.sol\";\nimport {IStaking} from \"./interfaces/IStaking.sol\";\n// import \"hardhat/console.sol\";\n\ncontract AVA is ExcludedFromFeeList, BaseUSDT, FirstLaunch, ERC20 {\n    bool public presale;\n    uint40 public coldTime = 1 minutes;\n\n    uint256 public AmountMarketingFee;\n    uint256 public TechnologyFee;\n    uint256 public AmountLPFee;\n\n    address public profitAddress;\n    address public marketingAddress;\n    address public technologyAddress;\n\n    uint256 public swapAtAmount = 20 ether;\n\n    mapping(address => bool) public _bcList;\n\n    mapping(address => uint256) public tOwnedU;\n    mapping(address => uint40) public lastBuyTime;\n    address public STAKING;\n\n    struct POOLUStatus {\n        uint112 bal; // pool usdt reserve last time update\n        uint40 t; // last update time\n    }\n\n    POOLUStatus public poolStatus;\n\n    function setPresale() external onlyOwner {\n        presale = true;\n        launch();\n        updatePoolReserve();\n    }\n\n    function setColdTime(uint40 _coldTime) external onlyOwner {\n        coldTime = _coldTime;\n    }\n\n    // Not removable; early calls to the staking contract.\n    function updatePoolReserve() public {\n        if (block.timestamp >= poolStatus.t + 1 hours) {\n            poolStatus.t = uint40(block.timestamp);\n            (uint112 reserveU,) = getReserves();\n            poolStatus.bal = reserveU;\n        }\n    }\n\n    function updatePoolReserve(uint112 reserveU) private {\n        if (block.timestamp >= poolStatus.t + 1 hours) {\n            poolStatus.t = uint40(block.timestamp);\n            poolStatus.bal = reserveU;\n        }\n    }\n\n    function getReserveU() external view returns (uint112) {\n        return poolStatus.bal;\n    }\n\n    constructor(\n        address _staking,\n        address profitAddress_,\n        address marketingAddress_,\n        address technologyAddress_,\n        address USDT_,\n        address ROUTER_\n    ) Owned(msg.sender) BaseUSDT(USDT_, ROUTER_) ERC20(\"AVA\", \"AVA\", 18, 1310000 ether) {\n        allowance[address(this)][address(uniswapV2Router)] = type(uint256).max;\n        IERC20(USDT_).approve(address(uniswapV2Router), type(uint256).max);\n        STAKING = _staking;\n        profitAddress = profitAddress_;\n        marketingAddress = marketingAddress_;\n        technologyAddress = technologyAddress_;\n\n        excludeFromFee(address(0xdead));\n        excludeFromFee(msg.sender);\n        excludeFromFee(address(this));\n        excludeFromFee(STAKING);\n        excludeFromFee(profitAddress);\n        excludeFromFee(marketingAddress);\n        excludeFromFee(technologyAddress);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual override {\n        require(isReward(sender) == 0, \"isReward != 0 !\");\n        if (\n            inSwapAndLiquify ||\n            _isExcludedFromFee[sender] ||\n            _isExcludedFromFee[recipient]\n        ) {\n            super._transfer(sender, recipient, amount);\n            return;\n        }\n        require(\n            !Helper.isContract(recipient) || uniswapV2Pair == recipient,\n            \"contract\"\n        );\n        if (uniswapV2Pair == sender) {\n            require(presale, \"pre\");\n\n            // buy\n            unchecked {\n                (uint112 reserveU, uint112 reserveThis) = getReserves();\n                require(amount <= reserveThis / 10, \"max cap buy\"); //每次买单最多只能卖池子的10%\n                updatePoolReserve(reserveU);\n                uint256 amountUBuy = Helper.getAmountIn(\n                    amount,\n                    reserveU,\n                    reserveThis\n                );\n                tOwnedU[recipient] = tOwnedU[recipient] + amountUBuy;\n                lastBuyTime[recipient] = uint40(block.timestamp);\n\n                uint256 fee;\n                uint256 burnAmount = balanceOf[address(0xdead)];\n                if (burnAmount < 1000000 * 10 ** 18) {\n                    fee = (amount * 25) / 1000; // 2.5%\n                    fee = 1000000 * 10 ** 18 - burnAmount > fee\n                        ? fee\n                        : 1000000 * 10 ** 18 - burnAmount;\n                    super._transfer(sender, address(0xdead), fee);\n                }\n                uint256 LPFee = (amount * 25) / 1000;\n                AmountLPFee += LPFee;\n                super._transfer(sender, address(this), LPFee);\n                super._transfer(sender, recipient, amount - fee - LPFee);\n            }\n        } else if (uniswapV2Pair == recipient) {\n            require(presale, \"pre\");\n            require(block.timestamp >= lastBuyTime[sender] + coldTime, \"cold\");\n            //sell\n            (uint112 reserveU, uint112 reserveThis) = getReserves();\n            require(amount <= reserveThis / 10, \"max cap sell\"); //每次卖单最多只能卖池子的20%\n            uint256 marketingFee = (amount * marketingFeeRate()) / 1000;\n            uint256 technologyFee = amount * 20 / 1000;\n            uint256 amountUOut = Helper.getAmountOut(\n                amount - marketingFee - technologyFee,\n                reserveThis,\n                reserveU\n            );\n            updatePoolReserve(reserveU);\n            uint256 fee;\n            if (tOwnedU[sender] >= amountUOut) {\n                unchecked {\n                    tOwnedU[sender] = tOwnedU[sender] - amountUOut;\n                }\n            } else if (tOwnedU[sender] > 0 && tOwnedU[sender] < amountUOut) {\n                uint256 profitU = amountUOut - tOwnedU[sender];\n                uint256 profitThis = Helper.getAmountOut(\n                    profitU,\n                    reserveU,\n                    reserveThis\n                );\n                fee = profitThis * 3 / 10;\n                tOwnedU[sender] = 0;\n            } else {\n                fee = amount * 3 / 10;\n                tOwnedU[sender] = 0;\n            }\n\n            if (fee > 0) {\n                super._transfer(sender, address(this), fee);\n                if (shouldSwapProfit(fee)) {\n                    swapProfit(fee);\n                }\n            }\n            if (shouldSwapTokenForFund(AmountLPFee + AmountMarketingFee + TechnologyFee)) {\n                swapTokenForFund();\n            }\n            super._transfer(sender, address(this), marketingFee + technologyFee);\n            AmountMarketingFee += marketingFee;\n            TechnologyFee += technologyFee;\n\n            super._transfer(sender, recipient, amount - fee - marketingFee - technologyFee);\n        } else {\n            // normal transfer\n            super._transfer(sender, recipient, amount);\n        }\n    }\n\n    function marketingFeeRate() internal view returns (uint256 result) {\n        result = 30;\n        if (\n            launchedAtTimestamp > 0 &&\n            block.timestamp - launchedAtTimestamp <= 15 minutes\n        ) {\n            result = 80;\n        }\n    }\n\n    function shouldSwapTokenForFund(uint256 amount) internal view returns (bool) {\n        if (amount >= swapAtAmount && !inSwapAndLiquify) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function swapTokenForFundByOwner() external onlyOwner {\n        swapTokenForFund();\n    }\n\n    function swapTokenForFund() internal lockTheSwap {\n        if (AmountMarketingFee > 0) {\n            swapTokenForUsdt(AmountMarketingFee, marketingAddress);\n            AmountMarketingFee = 0;\n        }\n        if (TechnologyFee > 0) {\n            swapTokenForUsdt(TechnologyFee, technologyAddress);\n            TechnologyFee = 0;\n        }\n\n        if (AmountLPFee > 0) {\n            swapAndLiquify(AmountLPFee);\n            AmountLPFee = 0;\n        }\n    }\n\n    function shouldSwapProfit(uint256 amount) internal view returns (bool) {\n        if (amount >= 1 gwei && !inSwapAndLiquify) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function swapProfit(uint256 tokenAmount) internal lockTheSwap {\n        uint256 bal = balanceOf[address(this)] -\n                    AmountLPFee -\n                    AmountMarketingFee -\n                    TechnologyFee;\n        uint256 t2 = tokenAmount * 2;\n        // It looks tokenAmount * 2, but it's actually just the current balance minus the fee\n        uint256 amountIn = t2 >= bal ? bal : t2;\n        unchecked {\n            swapTokenForUsdt(amountIn, address(distributor));\n            uint256 amount = IERC20(USDT).balanceOf(address(distributor));\n\n            IERC20(USDT).transferFrom(\n                address(distributor),\n                profitAddress,\n                amount\n            );\n        }\n    }\n\n    // When tokens is large,  The USDT allocation decreased, resulting in excess USDT.\n    function swapAndLiquify(uint256 tokens) internal {\n        IERC20 usdt = IERC20(USDT);\n        uint256 half = tokens / 2;\n        uint256 otherHalf = tokens - half;\n        uint256 initialBalance = usdt.balanceOf(address(this));\n        swapTokenForUsdt(half, address(distributor));\n        usdt.transferFrom(\n            address(distributor),\n            address(this),\n            usdt.balanceOf(address(distributor))\n        );\n        uint256 newBalance = usdt.balanceOf(address(this)) - initialBalance;\n        addLiquidity(otherHalf, newBalance);\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 usdtAmount) internal {\n        uniswapV2Router.addLiquidity(\n            address(this),\n            address(USDT),\n            tokenAmount,\n            usdtAmount,\n            0,\n            0,\n            address(0xdead),\n            block.timestamp\n        );\n    }\n\n    function swapTokenForUsdt(uint256 tokenAmount, address to) internal {\n        unchecked {\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = address(USDT);\n        // make the swap\n            uniswapV2Router\n            .swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                tokenAmount,\n                0, // accept any amount of ETH\n                path,\n                to,\n                block.timestamp\n            );\n        }\n    }\n\n    function recycle(uint256 amount) external {\n        require(STAKING == msg.sender, \"cycle\");\n        uint256 maxBurn = balanceOf[uniswapV2Pair] / 3;\n        uint256 burn_maount = amount >= maxBurn ? maxBurn : amount;\n        super._transfer(uniswapV2Pair, STAKING, burn_maount);\n        IUniswapV2Pair(uniswapV2Pair).sync();\n    }\n\n    function claimAbandonedBalance(address token, uint amount) external {\n        require(msg.sender == abandonedBalanceOwner, '!o');\n        require(token != address(this), '!this');\n\n        IERC20(token).transfer(msg.sender, amount);\n    }\n\n    function setSwapAtAmount(uint256 newValue) public onlyOwner {\n        swapAtAmount = newValue;\n    }\n\n    function setMarketingAddress(address addr) external onlyOwner {\n        marketingAddress = addr;\n        excludeFromFee(addr);\n    }\n\n    function setTechnologyAddress(address addr) external onlyOwner {\n        technologyAddress = addr;\n        excludeFromFee(addr);\n    }\n\n    function setProfitAddress(address addr) external onlyOwner {\n        profitAddress = addr;\n        excludeFromFee(addr);\n    }\n\n    function setStaking(address addr) external onlyOwner {\n        STAKING = addr;\n        excludeFromFee(addr);\n    }\n\n    function multi_bclist(address[] calldata addresses, bool value) public onlyOwner {\n        require(addresses.length < 201);\n        for (uint256 i; i < addresses.length; ++i) {\n            _bcList[addresses[i]] = value;\n        }\n    }\n\n    function isReward(address account) public view returns (uint256) {\n        if (_bcList[account]) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\ninterface IStaking {\n    function balances(address) external view returns (uint256);\n    function isPreacher(address) external  view returns(bool);\n}"
    },
    "contracts/lib/Helper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nlibrary Helper {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 10000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}